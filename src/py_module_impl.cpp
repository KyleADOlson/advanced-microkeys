#include "framework.h"
#include "MicroKeys.h"
#include "py_module_impl.h"

#define MOD_UP			0
#define MOD_DOWN		1
#define MOD_STAY_DOWN	4
#define MOD_WANT_DOWN	8

// #define DEBUG_KEY_PRESSES

class ModState {
public:
	SHORT VK;
	bool WantDown;
	bool StayDown;
	bool IsDown;

	ModState(SHORT vk) {
		this->VK = vk;
		this->WantDown = false;
		this->StayDown = false;
		this->IsDown = false;
	}

	void Hold() {
		if (this->WantDown || this->IsDown) {
			this->StayDown = true;
		}
	}

	void Release() {
		this->StayDown = false;
	}

	void Press(bool down) {
		if (this->WantDown) {
			this->WantDown = false;
			down = true;
		}
		if (this->StayDown) {
			down = true;
		}
		if (down != this->IsDown) {
			this->IsDown = down;
			UINT scanCode = MapVirtualKeyA(this->VK, 2);
			UINT extended = 0;
			if (scanCode == 0) {
				extended = KEYEVENTF_EXTENDEDKEY;
			}
			scanCode = MapVirtualKeyA(this->VK, 0);
			if (down) {
#if defined(DEBUG_KEY_PRESSES)
				{ char sz[100]; sprintf_s(sz, "PRESS MOD: %x\n", this->VK); OutputDebugStringA(sz); }
#else
				keybd_event((BYTE)this->VK, scanCode, extended, 0);
#endif
			}
			else {
#if defined(DEBUG_KEY_PRESSES)
				{ char sz[100]; sprintf_s(sz, "RELEASE MOD: %x\n", this->VK); OutputDebugStringA(sz); }
#else
				keybd_event((BYTE)this->VK, scanCode, extended | KEYEVENTF_KEYUP, 0);
#endif
			}
		}
	}
};

void press_key(char key, SHORT vk, ModState& shiftState, ModState& altState, ModState& ctrlState) {
	UINT scanCode = 0;
	UINT extended = 0;

	if (key != 0) {
		switch (key) {
		case '\n':
			vk = VK_RETURN;
			break;
		case '\r':
			vk = 0;
			break;
		case '\t':
			vk = VK_TAB;
			break;
		case '\b':
			vk = VK_BACK;
			break;
		default:
			vk = VkKeyScanA(key);
			break;
		}
	}
	scanCode = MapVirtualKeyA(vk, 2);
	if (scanCode == 0) {
		extended = KEYEVENTF_EXTENDEDKEY;
	}
	scanCode = MapVirtualKeyA(vk, 0);
	shiftState.Press((vk & 0x100) != 0);
	ctrlState.Press((vk & 0x200) != 0);
	altState.Press((vk & 0x400) != 0);
	vk &= 0xff;
	if (vk != 0) {
#if defined(DEBUG_KEY_PRESSES)
		{ char sz[100]; sprintf_s(sz, "PRESS/RELEASE: %x\n", vk); OutputDebugStringA(sz); }
#else
		keybd_event((BYTE)vk, scanCode, extended, 0);
		keybd_event((BYTE)vk, scanCode, extended | KEYEVENTF_KEYUP, 0);
#endif
	}
}

extern "C" void keys_press_invoke(const char* msg) {
	stringstream ss;
	ss << "keys.press('" << msg << "')\r\n";
	LogMessage(ss.str());

	ModState shiftState(VK_SHIFT);
	ModState ctrlState(VK_CONTROL);
	ModState altState(VK_MENU);

	bool in_curly = false;
	bool in_paren = false;
	string curly = "";
	bool first_key = true;

	for (const char* cur = msg; *cur; cur++) {
		DoEvents();

		if (in_curly) {
			if (curly.size() > 0 and *cur == '}') {
				in_curly = false;
				if (first_key) {
					first_key = false;
				}
				else {
					Sleep(20);
				}

				if (curly.size() == 1) {
					press_key(curly.c_str()[0], 0, shiftState, altState, ctrlState);
				}
				else {
					transform(curly.begin(), curly.end(), curly.begin(), toupper);
					// Start of generated section -- Do not edit!
					// This section is generated by create_key_constants.py, do not edit by hand
					/* Section CurlyDesc */
					if (curly == "BREAK") { press_key(0, 0x03, shiftState, altState, ctrlState); }
					else if (curly == "BACK") { press_key(0, 0x08, shiftState, altState, ctrlState); }
					else if (curly == "BS") { press_key(0, 0x08, shiftState, altState, ctrlState); }
					else if (curly == "BACKSPACE") { press_key(0, 0x08, shiftState, altState, ctrlState); }
					else if (curly == "BKSP") { press_key(0, 0x08, shiftState, altState, ctrlState); }
					else if (curly == "TAB") { press_key(0, 0x09, shiftState, altState, ctrlState); }
					else if (curly == "CLEAR") { press_key(0, 0x0C, shiftState, altState, ctrlState); }
					else if (curly == "ENTER") { press_key(0, 0x0D, shiftState, altState, ctrlState); }
					else if (curly == "RETURN") { press_key(0, 0x0D, shiftState, altState, ctrlState); }
					else if (curly == "CAPSLOCK") { press_key(0, 0x14, shiftState, altState, ctrlState); }
					else if (curly == "CAPS") { press_key(0, 0x14, shiftState, altState, ctrlState); }
					else if (curly == "CAPS_LOCK") { press_key(0, 0x14, shiftState, altState, ctrlState); }
					else if (curly == "ESC") { press_key(0, 0x1B, shiftState, altState, ctrlState); }
					else if (curly == "ESCAPE") { press_key(0, 0x1B, shiftState, altState, ctrlState); }
					else if (curly == "SPACE") { press_key(0, 0x20, shiftState, altState, ctrlState); }
					else if (curly == "PAGEUP") { press_key(0, 0x21, shiftState, altState, ctrlState); }
					else if (curly == "PAGE_UP") { press_key(0, 0x21, shiftState, altState, ctrlState); }
					else if (curly == "PGUP") { press_key(0, 0x21, shiftState, altState, ctrlState); }
					else if (curly == "PAGEDOWN") { press_key(0, 0x22, shiftState, altState, ctrlState); }
					else if (curly == "PAGE_DOWN") { press_key(0, 0x22, shiftState, altState, ctrlState); }
					else if (curly == "PGDN") { press_key(0, 0x22, shiftState, altState, ctrlState); }
					else if (curly == "END") { press_key(0, 0x23, shiftState, altState, ctrlState); }
					else if (curly == "HOME") { press_key(0, 0x24, shiftState, altState, ctrlState); }
					else if (curly == "LEFT") { press_key(0, 0x25, shiftState, altState, ctrlState); }
					else if (curly == "UP") { press_key(0, 0x26, shiftState, altState, ctrlState); }
					else if (curly == "RIGHT") { press_key(0, 0x27, shiftState, altState, ctrlState); }
					else if (curly == "DOWN") { press_key(0, 0x28, shiftState, altState, ctrlState); }
					else if (curly == "PRINTSCREEN") { press_key(0, 0x2C, shiftState, altState, ctrlState); }
					else if (curly == "PRINT_SCREEN") { press_key(0, 0x2C, shiftState, altState, ctrlState); }
					else if (curly == "PRTSC") { press_key(0, 0x2C, shiftState, altState, ctrlState); }
					else if (curly == "INS") { press_key(0, 0x2D, shiftState, altState, ctrlState); }
					else if (curly == "INSERT") { press_key(0, 0x2D, shiftState, altState, ctrlState); }
					else if (curly == "DEL") { press_key(0, 0x2E, shiftState, altState, ctrlState); }
					else if (curly == "DELETE") { press_key(0, 0x2E, shiftState, altState, ctrlState); }
					else if (curly == "HELP") { press_key(0, 0x2F, shiftState, altState, ctrlState); }
					else if (curly == "NUMLOCK") { press_key(0, 0x90, shiftState, altState, ctrlState); }
					else if (curly == "NUM_LOCK") { press_key(0, 0x90, shiftState, altState, ctrlState); }
					else if (curly == "NUM") { press_key(0, 0x90, shiftState, altState, ctrlState); }
					else if (curly == "SCROLLLOCK") { press_key(0, 0x91, shiftState, altState, ctrlState); }
					else if (curly == "SCROLL_LOCK") { press_key(0, 0x91, shiftState, altState, ctrlState); }
					else if (curly == "SCROLL") { press_key(0, 0x91, shiftState, altState, ctrlState); }
					else if (curly == "ALT") { press_key(0, 0x100, shiftState, altState, ctrlState); }
					else if (curly == "CONTROL") { press_key(0, 0x200, shiftState, altState, ctrlState); }
					else if (curly == "CTRL") { press_key(0, 0x200, shiftState, altState, ctrlState); }
					else if (curly == "SHIFT") { press_key(0, 0x400, shiftState, altState, ctrlState); }
					else if (curly == "WIN") { press_key(0, 0x800, shiftState, altState, ctrlState); }
					else if (curly == "WINDOWS") { press_key(0, 0x800, shiftState, altState, ctrlState); }
					else if (curly == "F1") { press_key(0, 0x70, shiftState, altState, ctrlState); }
					else if (curly == "F2") { press_key(0, 0x71, shiftState, altState, ctrlState); }
					else if (curly == "F3") { press_key(0, 0x72, shiftState, altState, ctrlState); }
					else if (curly == "F4") { press_key(0, 0x73, shiftState, altState, ctrlState); }
					else if (curly == "F5") { press_key(0, 0x74, shiftState, altState, ctrlState); }
					else if (curly == "F6") { press_key(0, 0x75, shiftState, altState, ctrlState); }
					else if (curly == "F7") { press_key(0, 0x76, shiftState, altState, ctrlState); }
					else if (curly == "F8") { press_key(0, 0x77, shiftState, altState, ctrlState); }
					else if (curly == "F9") { press_key(0, 0x78, shiftState, altState, ctrlState); }
					else if (curly == "F10") { press_key(0, 0x79, shiftState, altState, ctrlState); }
					else if (curly == "F11") { press_key(0, 0x7A, shiftState, altState, ctrlState); }
					else if (curly == "F12") { press_key(0, 0x7B, shiftState, altState, ctrlState); }
					else if (curly == "F13") { press_key(0, 0x7C, shiftState, altState, ctrlState); }
					else if (curly == "F14") { press_key(0, 0x7D, shiftState, altState, ctrlState); }
					else if (curly == "F15") { press_key(0, 0x7E, shiftState, altState, ctrlState); }
					else if (curly == "F16") { press_key(0, 0x7F, shiftState, altState, ctrlState); }
					// End of generated section -- Do not edit!
				}
				curly = "";
			}
			else {
				curly += *cur;
			}
		}
		else {
			if (!in_paren and *cur == '(') {
				in_paren = true;
				shiftState.Hold();
				ctrlState.Hold();
				altState.Hold();
			}
			else if (in_paren and *cur == ')') {
				in_paren = false;
				shiftState.Release();
				ctrlState.Release();
				altState.Release();
			}
			else if (*cur == '{') {
				in_curly = true;
			}
			else if (*cur == '+') {
				shiftState.WantDown = true;
			}
			else if (*cur == '%') {
				altState.WantDown = true;
			}
			else if (*cur == '^') {
				ctrlState.WantDown = true;
			}
			else {
				if (first_key) {
					first_key = false;
				}
				else {
					Sleep(20);
				}

				switch (*cur) {
				case '~':
					press_key('\n', 0, shiftState, altState, ctrlState);
					break;
				default:
					press_key(*cur, 0, shiftState, altState, ctrlState);
					break;
				}
			}
		}
	}
	shiftState.Release();
	shiftState.WantDown = false;
	ctrlState.Release();
	ctrlState.WantDown = false;
	altState.Release();
	altState.WantDown = false;
	press_key(0, 0, shiftState, altState, ctrlState);
}

extern "C" void keys_press_raw_invoke(const char* msg) {
	stringstream ss;
	ss << "keys.press_raw('" << msg << "')\r\n";
	LogMessage(ss.str());

	ModState shiftState(VK_SHIFT);
	ModState ctrlState(VK_CONTROL);
	ModState altState(VK_MENU);

	for (const char* cur = msg; *cur; cur++) {
		DoEvents();
		if (cur != msg) {
			Sleep(20);
		}

		press_key(*cur, 0, shiftState, altState, ctrlState);
	}
	press_key(0, 0, shiftState, altState, ctrlState);
}

void AddDesc(stringstream& desc, string val) {
	if (desc.tellp() > 0) {
		desc << "+";
	}
	desc << val;
}

extern "C" void key_press_store_fun(int vk, char* name, void* fun) {
	KeyData key;
	key.ID = (int)GetKeys().size();
	if (vk != 0) {
		RegisterHotKey(GetMainWindow(), key.ID + 1, (vk & 0xff00) >> 8, vk & 0xff);
	}
	key.VK = vk;
	key.Name = string(name);
	key.PythonFunction = fun;

	stringstream ss;
	if (vk != 0) {
		stringstream desc;
		// Start of generated section -- Do not edit!
		// This section is generated by create_key_constants.py, do not edit by hand
		/* Section AddDesc */
		if ((vk & 0x100) > 0) { AddDesc(desc, "Alt"); }
		if ((vk & 0x200) > 0) { AddDesc(desc, "Control"); }
		if ((vk & 0x400) > 0) { AddDesc(desc, "Shift"); }
		if ((vk & 0x800) > 0) { AddDesc(desc, "Windows"); }
		switch (vk & 0xFF) {
		case 0x03: AddDesc(desc, "Break"); break;
		case 0x08: AddDesc(desc, "Back"); break;
		case 0x09: AddDesc(desc, "Tab"); break;
		case 0x0C: AddDesc(desc, "Clear"); break;
		case 0x0D: AddDesc(desc, "Enter"); break;
		case 0x14: AddDesc(desc, "CapsLock"); break;
		case 0x1B: AddDesc(desc, "Escape"); break;
		case 0x20: AddDesc(desc, "Space"); break;
		case 0x21: AddDesc(desc, "PageUp"); break;
		case 0x22: AddDesc(desc, "PageDown"); break;
		case 0x23: AddDesc(desc, "End"); break;
		case 0x24: AddDesc(desc, "Home"); break;
		case 0x25: AddDesc(desc, "Left"); break;
		case 0x26: AddDesc(desc, "Up"); break;
		case 0x27: AddDesc(desc, "Right"); break;
		case 0x28: AddDesc(desc, "Down"); break;
		case 0x2C: AddDesc(desc, "PrintScreen"); break;
		case 0x2D: AddDesc(desc, "Insert"); break;
		case 0x2E: AddDesc(desc, "Delete"); break;
		case 0x2F: AddDesc(desc, "Help"); break;
		case 0x90: AddDesc(desc, "NumLock"); break;
		case 0x91: AddDesc(desc, "ScrollLock"); break;
		case 0x30: AddDesc(desc, "0"); break;
		case 0x31: AddDesc(desc, "1"); break;
		case 0x32: AddDesc(desc, "2"); break;
		case 0x33: AddDesc(desc, "3"); break;
		case 0x34: AddDesc(desc, "4"); break;
		case 0x35: AddDesc(desc, "5"); break;
		case 0x36: AddDesc(desc, "6"); break;
		case 0x37: AddDesc(desc, "7"); break;
		case 0x38: AddDesc(desc, "8"); break;
		case 0x39: AddDesc(desc, "9"); break;
		case 0x41: AddDesc(desc, "A"); break;
		case 0x42: AddDesc(desc, "B"); break;
		case 0x43: AddDesc(desc, "C"); break;
		case 0x44: AddDesc(desc, "D"); break;
		case 0x45: AddDesc(desc, "E"); break;
		case 0x46: AddDesc(desc, "F"); break;
		case 0x47: AddDesc(desc, "G"); break;
		case 0x48: AddDesc(desc, "H"); break;
		case 0x49: AddDesc(desc, "I"); break;
		case 0x4A: AddDesc(desc, "J"); break;
		case 0x4B: AddDesc(desc, "K"); break;
		case 0x4C: AddDesc(desc, "L"); break;
		case 0x4D: AddDesc(desc, "M"); break;
		case 0x4E: AddDesc(desc, "N"); break;
		case 0x4F: AddDesc(desc, "O"); break;
		case 0x50: AddDesc(desc, "P"); break;
		case 0x51: AddDesc(desc, "Q"); break;
		case 0x52: AddDesc(desc, "R"); break;
		case 0x53: AddDesc(desc, "S"); break;
		case 0x54: AddDesc(desc, "T"); break;
		case 0x55: AddDesc(desc, "U"); break;
		case 0x56: AddDesc(desc, "V"); break;
		case 0x57: AddDesc(desc, "W"); break;
		case 0x58: AddDesc(desc, "X"); break;
		case 0x59: AddDesc(desc, "Y"); break;
		case 0x5A: AddDesc(desc, "Z"); break;
		case 0x70: AddDesc(desc, "F1"); break;
		case 0x71: AddDesc(desc, "F2"); break;
		case 0x72: AddDesc(desc, "F3"); break;
		case 0x73: AddDesc(desc, "F4"); break;
		case 0x74: AddDesc(desc, "F5"); break;
		case 0x75: AddDesc(desc, "F6"); break;
		case 0x76: AddDesc(desc, "F7"); break;
		case 0x77: AddDesc(desc, "F8"); break;
		case 0x78: AddDesc(desc, "F9"); break;
		case 0x79: AddDesc(desc, "F10"); break;
		case 0x7A: AddDesc(desc, "F11"); break;
		case 0x7B: AddDesc(desc, "F12"); break;
		case 0x7C: AddDesc(desc, "F13"); break;
		case 0x7D: AddDesc(desc, "F14"); break;
		case 0x7E: AddDesc(desc, "F15"); break;
		case 0x7F: AddDesc(desc, "F16"); break;
		default: AddDesc(desc, "<Unknown>"); break;
		}
		// End of generated section -- Do not edit!
		key.Description = desc.str();
		ss << "Registered " << desc.str() << "\r\n";
	}
	else {
		ss << "Registered '" << key.Name << "'\r\n";
	}
	GetKeys().push_back(key);
	LogMessage(ss.str());
}

extern "C" char* clip_copy_invoke() {
	LogMessage("clip.copy()\r\n");

	char* ret = NULL;
	if (OpenClipboard(GetMainWindow())) {
		HANDLE hData = GetClipboardData(CF_TEXT);
		if (hData) {
			char* clip = (char*)GlobalLock(hData);
			if (clip != NULL) {
				ret = (char*)malloc(strlen(clip) + 2);
				if (ret != NULL) {
					strcpy_s(ret, strlen(clip) + 1, clip);
				}
				GlobalUnlock(clip);
			}
		}
		CloseClipboard();
	}
	return ret;
}

extern "C" void clip_paste_invoke(const char* data) {
	stringstream ss;
	ss << "clip.paste('" << data << "')\r\n";
	LogMessage(ss.str());

	if (OpenClipboard(GetMainWindow())) {
		HGLOBAL hMem = GlobalAlloc(GMEM_MOVEABLE, strlen(data) + 2);
		if (hMem != NULL) {
			char* locked = (char*)GlobalLock(hMem);
			if (locked != NULL) {
				strcpy_s(locked, strlen(data) + 2, data);
				GlobalUnlock(hMem);
				EmptyClipboard();
				SetClipboardData(CF_TEXT, hMem);
			}
		}
		CloseClipboard();
	}
}
