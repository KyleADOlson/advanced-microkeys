#include "framework.h"
#include "MicroKeys.h"
#include "py_module_impl.h"

#define MOD_UP			0
#define MOD_DOWN		1
#define MOD_STAY_DOWN	4
#define MOD_WANT_DOWN	8

// #define DEBUG_KEY_PRESSES

class ModState {
public:
	SHORT VK;
	bool WantDown;
	bool StayDown;
	bool IsDown;
	string Name;

	ModState(SHORT vk, string name) {
		this->Name = name;
		this->VK = vk;
		this->WantDown = false;
		this->StayDown = false;
		this->IsDown = false;
	}

	void Hold() {
		if (this->WantDown || this->IsDown) {
			this->StayDown = true;
		}
	}

	void Release() {
		this->StayDown = false;
	}

	void Press(bool down) {
		if (this->WantDown) {
			this->WantDown = false;
			down = true;
		}
		if (this->StayDown) {
			down = true;
		}
		if (down != this->IsDown) {
			this->IsDown = down;
			UINT scanCode = MapVirtualKeyA(this->VK, 2);
			UINT extended = 0;
			if (scanCode == 0) {
				extended = KEYEVENTF_EXTENDEDKEY;
			}
			scanCode = MapVirtualKeyA(this->VK, 0);
			if (down) {
#if defined(DEBUG_KEY_PRESSES)
				{ char sz[100]; sprintf_s(sz, "PRESS MOD: %x\n", this->VK); OutputDebugStringA(sz); }
#else
				if (TestLogEnabled()) {
					stringstream ss;
					ss << "  Key: " << this->Name << " down";
					TestLog(ss.str());
				}
				else {
					keybd_event((BYTE)this->VK, scanCode, extended, 0);
				}
#endif
			}
			else {
#if defined(DEBUG_KEY_PRESSES)
				{ char sz[100]; sprintf_s(sz, "RELEASE MOD: %x\n", this->VK); OutputDebugStringA(sz); }
#else
				if (TestLogEnabled()) {
					stringstream ss;
					ss << "  Key: " << this->Name << " up";
					TestLog(ss.str());
				}
				else {
					keybd_event((BYTE)this->VK, scanCode, extended | KEYEVENTF_KEYUP, 0);
				}
#endif
			}
		}
	}
};

extern "C" void handle_print_impl(int fd, void* buf, int len) {
	while (len > 0 && (((char*)buf)[len - 1] == '\n' || ((char*)buf)[len - 1] == '\r')) {
		len--;
	}
	if (len > 0) {
		string str((char*)buf, len);
		if (TestLogEnabled()) {
			TestLog((fd == 1 ? "STDOUT: " : "STDERR: ") + str);
		}
		LogMessage((fd == 1 ? "STDOUT: " : "STDERR: ") + str);
	}
}

void press_key(char key, SHORT vk, ModState& shiftState, ModState& altState, ModState& ctrlState) {
	UINT scanCode = 0;
	UINT extended = 0;

	if (key != 0) {
		switch (key) {
		case '\n':
			vk = VK_RETURN;
			break;
		case '\r':
			vk = 0;
			break;
		case '\t':
			vk = VK_TAB;
			break;
		case '\b':
			vk = VK_BACK;
			break;
		default:
			vk = VkKeyScanA(key);
			break;
		}
	}
	scanCode = MapVirtualKeyA(vk, 2);
	if (scanCode == 0) {
		extended = KEYEVENTF_EXTENDEDKEY;
	}
	scanCode = MapVirtualKeyA(vk, 0);
	shiftState.Press((vk & 0x100) != 0);
	ctrlState.Press((vk & 0x200) != 0);
	altState.Press((vk & 0x400) != 0);
	vk &= 0xff;
	if (vk != 0) {
#if defined(DEBUG_KEY_PRESSES)
		{ char sz[100]; sprintf_s(sz, "PRESS/RELEASE: %x\n", vk); OutputDebugStringA(sz); }
#else
		if (TestLogEnabled()) {
			// Start of generated section -- Do not edit!
			// This section is generated by create_key_constants.py, do not edit by hand
			/* Section TestLog */
			if (vk == 0x03) { TestLog("  Key: Break press"); }
			else if (vk == 0x08) { TestLog("  Key: Back press"); }
			else if (vk == 0x09) { TestLog("  Key: Tab press"); }
			else if (vk == 0x0C) { TestLog("  Key: Clear press"); }
			else if (vk == 0x0D) { TestLog("  Key: Enter press"); }
			else if (vk == 0x14) { TestLog("  Key: CapsLock press"); }
			else if (vk == 0x1B) { TestLog("  Key: Escape press"); }
			else if (vk == 0x20) { TestLog("  Key: Space press"); }
			else if (vk == 0x21) { TestLog("  Key: PageUp press"); }
			else if (vk == 0x22) { TestLog("  Key: PageDown press"); }
			else if (vk == 0x23) { TestLog("  Key: End press"); }
			else if (vk == 0x24) { TestLog("  Key: Home press"); }
			else if (vk == 0x25) { TestLog("  Key: Left press"); }
			else if (vk == 0x26) { TestLog("  Key: Up press"); }
			else if (vk == 0x27) { TestLog("  Key: Right press"); }
			else if (vk == 0x28) { TestLog("  Key: Down press"); }
			else if (vk == 0x2C) { TestLog("  Key: PrintScreen press"); }
			else if (vk == 0x2D) { TestLog("  Key: Insert press"); }
			else if (vk == 0x2E) { TestLog("  Key: Delete press"); }
			else if (vk == 0x2F) { TestLog("  Key: Help press"); }
			else if (vk == 0x90) { TestLog("  Key: NumLock press"); }
			else if (vk == 0x91) { TestLog("  Key: ScrollLock press"); }
			else if (vk == 0xBA) { TestLog("  Key: SemiColon press"); }
			else if (vk == 0xBB) { TestLog("  Key: Plus press"); }
			else if (vk == 0xBC) { TestLog("  Key: Comma press"); }
			else if (vk == 0xBD) { TestLog("  Key: Minus press"); }
			else if (vk == 0xBE) { TestLog("  Key: Period press"); }
			else if (vk == 0xBF) { TestLog("  Key: Slash press"); }
			else if (vk == 0xC0) { TestLog("  Key: BackQuote press"); }
			else if (vk == 0xDB) { TestLog("  Key: OpenBracket press"); }
			else if (vk == 0xDC) { TestLog("  Key: BackSlash press"); }
			else if (vk == 0xDD) { TestLog("  Key: CloseBracket press"); }
			else if (vk == 0xDE) { TestLog("  Key: SingleQuote press"); }
			else if (vk == 0x100) { TestLog("  Key: Alt press"); }
			else if (vk == 0x200) { TestLog("  Key: Control press"); }
			else if (vk == 0x400) { TestLog("  Key: Shift press"); }
			else if (vk == 0x800) { TestLog("  Key: Windows press"); }
			else if (vk == 0x30) { TestLog("  Key: 0 press"); }
			else if (vk == 0x31) { TestLog("  Key: 1 press"); }
			else if (vk == 0x32) { TestLog("  Key: 2 press"); }
			else if (vk == 0x33) { TestLog("  Key: 3 press"); }
			else if (vk == 0x34) { TestLog("  Key: 4 press"); }
			else if (vk == 0x35) { TestLog("  Key: 5 press"); }
			else if (vk == 0x36) { TestLog("  Key: 6 press"); }
			else if (vk == 0x37) { TestLog("  Key: 7 press"); }
			else if (vk == 0x38) { TestLog("  Key: 8 press"); }
			else if (vk == 0x39) { TestLog("  Key: 9 press"); }
			else if (vk == 0x41) { TestLog("  Key: A press"); }
			else if (vk == 0x42) { TestLog("  Key: B press"); }
			else if (vk == 0x43) { TestLog("  Key: C press"); }
			else if (vk == 0x44) { TestLog("  Key: D press"); }
			else if (vk == 0x45) { TestLog("  Key: E press"); }
			else if (vk == 0x46) { TestLog("  Key: F press"); }
			else if (vk == 0x47) { TestLog("  Key: G press"); }
			else if (vk == 0x48) { TestLog("  Key: H press"); }
			else if (vk == 0x49) { TestLog("  Key: I press"); }
			else if (vk == 0x4A) { TestLog("  Key: J press"); }
			else if (vk == 0x4B) { TestLog("  Key: K press"); }
			else if (vk == 0x4C) { TestLog("  Key: L press"); }
			else if (vk == 0x4D) { TestLog("  Key: M press"); }
			else if (vk == 0x4E) { TestLog("  Key: N press"); }
			else if (vk == 0x4F) { TestLog("  Key: O press"); }
			else if (vk == 0x50) { TestLog("  Key: P press"); }
			else if (vk == 0x51) { TestLog("  Key: Q press"); }
			else if (vk == 0x52) { TestLog("  Key: R press"); }
			else if (vk == 0x53) { TestLog("  Key: S press"); }
			else if (vk == 0x54) { TestLog("  Key: T press"); }
			else if (vk == 0x55) { TestLog("  Key: U press"); }
			else if (vk == 0x56) { TestLog("  Key: V press"); }
			else if (vk == 0x57) { TestLog("  Key: W press"); }
			else if (vk == 0x58) { TestLog("  Key: X press"); }
			else if (vk == 0x59) { TestLog("  Key: Y press"); }
			else if (vk == 0x5A) { TestLog("  Key: Z press"); }
			else if (vk == 0x70) { TestLog("  Key: F1 press"); }
			else if (vk == 0x71) { TestLog("  Key: F2 press"); }
			else if (vk == 0x72) { TestLog("  Key: F3 press"); }
			else if (vk == 0x73) { TestLog("  Key: F4 press"); }
			else if (vk == 0x74) { TestLog("  Key: F5 press"); }
			else if (vk == 0x75) { TestLog("  Key: F6 press"); }
			else if (vk == 0x76) { TestLog("  Key: F7 press"); }
			else if (vk == 0x77) { TestLog("  Key: F8 press"); }
			else if (vk == 0x78) { TestLog("  Key: F9 press"); }
			else if (vk == 0x79) { TestLog("  Key: F10 press"); }
			else if (vk == 0x7A) { TestLog("  Key: F11 press"); }
			else if (vk == 0x7B) { TestLog("  Key: F12 press"); }
			else if (vk == 0x7C) { TestLog("  Key: F13 press"); }
			else if (vk == 0x7D) { TestLog("  Key: F14 press"); }
			else if (vk == 0x7E) { TestLog("  Key: F15 press"); }
			else if (vk == 0x7F) { TestLog("  Key: F16 press"); }
			// End of generated section -- Do not edit!
			else {
				stringstream ss;
				ss << "  Key: 0x" << hex << vk << " press";
				TestLog(ss.str());
			}
		}
		else {
			keybd_event((BYTE)vk, scanCode, extended, 0);
			keybd_event((BYTE)vk, scanCode, extended | KEYEVENTF_KEYUP, 0);
		}
#endif
	}
}

extern "C" void keys_log_invoke(const char* msg) {
	if (TestLogEnabled()) {
		stringstream ss;
		ss << "key.log(\"" << msg << "\")";
		TestLog(ss.str());
	}
	stringstream ss;
	ss << "keys.log('" << msg << "')";
	LogMessage(ss.str());
}

extern "C" void keys_press_invoke(const char* msg) {
	if (TestLogEnabled()) {
		stringstream ss;
		ss << "key.press(\"" << msg << "\")";
		TestLog(ss.str());
	}
	stringstream ss;
	ss << "keys.press('" << msg << "')";
	LogMessage(ss.str());

	ModState shiftState(VK_SHIFT, "Shift");
	ModState ctrlState(VK_CONTROL, "Control");
	ModState altState(VK_MENU, "Alt");

	bool in_curly = false;
	bool in_paren = false;
	string curly = "";
	bool first_key = true;

	for (const char* cur = msg; *cur; cur++) {
		DoEvents();

		if (in_curly) {
			if (curly.size() > 0 and *cur == '}') {
				in_curly = false;
				if (first_key) {
					first_key = false;
				}
				else {
					Sleep(20);
				}

				if (curly.size() == 1) {
					press_key(curly.c_str()[0], 0, shiftState, altState, ctrlState);
				}
				else {
					for (auto& c : curly) {
						c = toupper(c);
					}
					// Start of generated section -- Do not edit!
					// This section is generated by create_key_constants.py, do not edit by hand
					/* Section CurlyDesc */
					if (curly == "BREAK") { press_key(0, 0x03, shiftState, altState, ctrlState); }
					else if (curly == "BACK") { press_key(0, 0x08, shiftState, altState, ctrlState); }
					else if (curly == "BS") { press_key(0, 0x08, shiftState, altState, ctrlState); }
					else if (curly == "BACKSPACE") { press_key(0, 0x08, shiftState, altState, ctrlState); }
					else if (curly == "BKSP") { press_key(0, 0x08, shiftState, altState, ctrlState); }
					else if (curly == "TAB") { press_key(0, 0x09, shiftState, altState, ctrlState); }
					else if (curly == "CLEAR") { press_key(0, 0x0C, shiftState, altState, ctrlState); }
					else if (curly == "ENTER") { press_key(0, 0x0D, shiftState, altState, ctrlState); }
					else if (curly == "RETURN") { press_key(0, 0x0D, shiftState, altState, ctrlState); }
					else if (curly == "CAPSLOCK") { press_key(0, 0x14, shiftState, altState, ctrlState); }
					else if (curly == "CAPS") { press_key(0, 0x14, shiftState, altState, ctrlState); }
					else if (curly == "CAPS_LOCK") { press_key(0, 0x14, shiftState, altState, ctrlState); }
					else if (curly == "ESC") { press_key(0, 0x1B, shiftState, altState, ctrlState); }
					else if (curly == "ESCAPE") { press_key(0, 0x1B, shiftState, altState, ctrlState); }
					else if (curly == "SPACE") { press_key(0, 0x20, shiftState, altState, ctrlState); }
					else if (curly == "PAGEUP") { press_key(0, 0x21, shiftState, altState, ctrlState); }
					else if (curly == "PAGE_UP") { press_key(0, 0x21, shiftState, altState, ctrlState); }
					else if (curly == "PGUP") { press_key(0, 0x21, shiftState, altState, ctrlState); }
					else if (curly == "PAGEDOWN") { press_key(0, 0x22, shiftState, altState, ctrlState); }
					else if (curly == "PAGE_DOWN") { press_key(0, 0x22, shiftState, altState, ctrlState); }
					else if (curly == "PGDN") { press_key(0, 0x22, shiftState, altState, ctrlState); }
					else if (curly == "END") { press_key(0, 0x23, shiftState, altState, ctrlState); }
					else if (curly == "HOME") { press_key(0, 0x24, shiftState, altState, ctrlState); }
					else if (curly == "LEFT") { press_key(0, 0x25, shiftState, altState, ctrlState); }
					else if (curly == "UP") { press_key(0, 0x26, shiftState, altState, ctrlState); }
					else if (curly == "RIGHT") { press_key(0, 0x27, shiftState, altState, ctrlState); }
					else if (curly == "DOWN") { press_key(0, 0x28, shiftState, altState, ctrlState); }
					else if (curly == "PRINTSCREEN") { press_key(0, 0x2C, shiftState, altState, ctrlState); }
					else if (curly == "PRINT_SCREEN") { press_key(0, 0x2C, shiftState, altState, ctrlState); }
					else if (curly == "PRTSC") { press_key(0, 0x2C, shiftState, altState, ctrlState); }
					else if (curly == "INS") { press_key(0, 0x2D, shiftState, altState, ctrlState); }
					else if (curly == "INSERT") { press_key(0, 0x2D, shiftState, altState, ctrlState); }
					else if (curly == "DEL") { press_key(0, 0x2E, shiftState, altState, ctrlState); }
					else if (curly == "DELETE") { press_key(0, 0x2E, shiftState, altState, ctrlState); }
					else if (curly == "HELP") { press_key(0, 0x2F, shiftState, altState, ctrlState); }
					else if (curly == "NUMLOCK") { press_key(0, 0x90, shiftState, altState, ctrlState); }
					else if (curly == "NUM_LOCK") { press_key(0, 0x90, shiftState, altState, ctrlState); }
					else if (curly == "NUM") { press_key(0, 0x90, shiftState, altState, ctrlState); }
					else if (curly == "SCROLLLOCK") { press_key(0, 0x91, shiftState, altState, ctrlState); }
					else if (curly == "SCROLL_LOCK") { press_key(0, 0x91, shiftState, altState, ctrlState); }
					else if (curly == "SCROLL") { press_key(0, 0x91, shiftState, altState, ctrlState); }
					else if (curly == "SEMI_COLON") { press_key(0, 0xBA, shiftState, altState, ctrlState); }
					else if (curly == "SEMI") { press_key(0, 0xBA, shiftState, altState, ctrlState); }
					else if (curly == "SEMICOLON") { press_key(0, 0xBA, shiftState, altState, ctrlState); }
					else if (curly == "PLUS") { press_key(0, 0xBB, shiftState, altState, ctrlState); }
					else if (curly == "COMMA") { press_key(0, 0xBC, shiftState, altState, ctrlState); }
					else if (curly == "MINUS") { press_key(0, 0xBD, shiftState, altState, ctrlState); }
					else if (curly == "DASH") { press_key(0, 0xBD, shiftState, altState, ctrlState); }
					else if (curly == "PERIOD") { press_key(0, 0xBE, shiftState, altState, ctrlState); }
					else if (curly == "DOT") { press_key(0, 0xBE, shiftState, altState, ctrlState); }
					else if (curly == "SLASH") { press_key(0, 0xBF, shiftState, altState, ctrlState); }
					else if (curly == "FORWARD_SLASH") { press_key(0, 0xBF, shiftState, altState, ctrlState); }
					else if (curly == "FORWARDSLASH") { press_key(0, 0xBF, shiftState, altState, ctrlState); }
					else if (curly == "BACK_QUOTE") { press_key(0, 0xC0, shiftState, altState, ctrlState); }
					else if (curly == "BACKQUOTE") { press_key(0, 0xC0, shiftState, altState, ctrlState); }
					else if (curly == "OPEN_BRACKET") { press_key(0, 0xDB, shiftState, altState, ctrlState); }
					else if (curly == "OPENBRACKET") { press_key(0, 0xDB, shiftState, altState, ctrlState); }
					else if (curly == "BACK_SLASH") { press_key(0, 0xDC, shiftState, altState, ctrlState); }
					else if (curly == "BACKSLASH") { press_key(0, 0xDC, shiftState, altState, ctrlState); }
					else if (curly == "CLOSE_BRACKET") { press_key(0, 0xDD, shiftState, altState, ctrlState); }
					else if (curly == "CLOSEBRACKET") { press_key(0, 0xDD, shiftState, altState, ctrlState); }
					else if (curly == "QUOTE") { press_key(0, 0xDE, shiftState, altState, ctrlState); }
					else if (curly == "SINGLE_QUOTE") { press_key(0, 0xDE, shiftState, altState, ctrlState); }
					else if (curly == "SINGLEQUOTE") { press_key(0, 0xDE, shiftState, altState, ctrlState); }
					else if (curly == "ALT") { press_key(0, 0x100, shiftState, altState, ctrlState); }
					else if (curly == "CONTROL") { press_key(0, 0x200, shiftState, altState, ctrlState); }
					else if (curly == "CTRL") { press_key(0, 0x200, shiftState, altState, ctrlState); }
					else if (curly == "SHIFT") { press_key(0, 0x400, shiftState, altState, ctrlState); }
					else if (curly == "WIN") { press_key(0, 0x800, shiftState, altState, ctrlState); }
					else if (curly == "WINDOWS") { press_key(0, 0x800, shiftState, altState, ctrlState); }
					else if (curly == "F1") { press_key(0, 0x70, shiftState, altState, ctrlState); }
					else if (curly == "F2") { press_key(0, 0x71, shiftState, altState, ctrlState); }
					else if (curly == "F3") { press_key(0, 0x72, shiftState, altState, ctrlState); }
					else if (curly == "F4") { press_key(0, 0x73, shiftState, altState, ctrlState); }
					else if (curly == "F5") { press_key(0, 0x74, shiftState, altState, ctrlState); }
					else if (curly == "F6") { press_key(0, 0x75, shiftState, altState, ctrlState); }
					else if (curly == "F7") { press_key(0, 0x76, shiftState, altState, ctrlState); }
					else if (curly == "F8") { press_key(0, 0x77, shiftState, altState, ctrlState); }
					else if (curly == "F9") { press_key(0, 0x78, shiftState, altState, ctrlState); }
					else if (curly == "F10") { press_key(0, 0x79, shiftState, altState, ctrlState); }
					else if (curly == "F11") { press_key(0, 0x7A, shiftState, altState, ctrlState); }
					else if (curly == "F12") { press_key(0, 0x7B, shiftState, altState, ctrlState); }
					else if (curly == "F13") { press_key(0, 0x7C, shiftState, altState, ctrlState); }
					else if (curly == "F14") { press_key(0, 0x7D, shiftState, altState, ctrlState); }
					else if (curly == "F15") { press_key(0, 0x7E, shiftState, altState, ctrlState); }
					else if (curly == "F16") { press_key(0, 0x7F, shiftState, altState, ctrlState); }
					// End of generated section -- Do not edit!
				}
				curly = "";
			}
			else {
				curly += *cur;
			}
		}
		else {
			if (!in_paren and *cur == '(') {
				in_paren = true;
				shiftState.Hold();
				ctrlState.Hold();
				altState.Hold();
			}
			else if (in_paren and *cur == ')') {
				in_paren = false;
				shiftState.Release();
				ctrlState.Release();
				altState.Release();
			}
			else if (*cur == '{') {
				in_curly = true;
			}
			else if (*cur == '+') {
				shiftState.WantDown = true;
			}
			else if (*cur == '%') {
				altState.WantDown = true;
			}
			else if (*cur == '^') {
				ctrlState.WantDown = true;
			}
			else {
				if (first_key) {
					first_key = false;
				}
				else {
					Sleep(20);
				}

				switch (*cur) {
				case '~':
					press_key('\n', 0, shiftState, altState, ctrlState);
					break;
				default:
					press_key(*cur, 0, shiftState, altState, ctrlState);
					break;
				}
			}
		}
	}
	shiftState.Release();
	shiftState.WantDown = false;
	ctrlState.Release();
	ctrlState.WantDown = false;
	altState.Release();
	altState.WantDown = false;
	press_key(0, 0, shiftState, altState, ctrlState);
}

extern "C" void keys_press_raw_invoke(const char* msg) {
	if (TestLogEnabled()) {
		stringstream ss;
		ss << "keys.press_raw(\"" << msg << "\")";
		TestLog(ss.str());
	}
	stringstream ss;
	ss << "keys.press_raw('" << msg << "')";
	LogMessage(ss.str());

	ModState shiftState(VK_SHIFT, "Shift");
	ModState ctrlState(VK_CONTROL, "Control");
	ModState altState(VK_MENU, "Alt");

	for (const char* cur = msg; *cur; cur++) {
		DoEvents();
		if (cur != msg) {
			Sleep(20);
		}

		press_key(*cur, 0, shiftState, altState, ctrlState);
	}
	press_key(0, 0, shiftState, altState, ctrlState);
}

void AddDesc(stringstream& desc, string val) {
	if (desc.tellp() > 0) {
		desc << "+";
	}
	desc << val;
}

extern "C" void key_press_store_fun(int vk, char* name, void* fun) {
	KeyData key;
	key.ID = (int)GetKeys().size();
	if (vk != 0) {
		RegisterHotKey(GetMainWindow(), key.ID + 1, (vk & 0xff00) >> 8, vk & 0xff);
	}
	key.VK = vk;
	key.Name = string(name);
	key.PythonFunction = fun;

	stringstream ss;
	if (vk != 0) {
		stringstream desc;
		// Start of generated section -- Do not edit!
		// This section is generated by create_key_constants.py, do not edit by hand
		/* Section AddDesc */
		if ((vk & 0x100) > 0) { AddDesc(desc, "Alt"); }
		if ((vk & 0x200) > 0) { AddDesc(desc, "Control"); }
		if ((vk & 0x400) > 0) { AddDesc(desc, "Shift"); }
		if ((vk & 0x800) > 0) { AddDesc(desc, "Windows"); }
		switch (vk & 0xFF) {
		case 0x03: AddDesc(desc, "Break"); break;
		case 0x08: AddDesc(desc, "Back"); break;
		case 0x09: AddDesc(desc, "Tab"); break;
		case 0x0C: AddDesc(desc, "Clear"); break;
		case 0x0D: AddDesc(desc, "Enter"); break;
		case 0x14: AddDesc(desc, "CapsLock"); break;
		case 0x1B: AddDesc(desc, "Escape"); break;
		case 0x20: AddDesc(desc, "Space"); break;
		case 0x21: AddDesc(desc, "PageUp"); break;
		case 0x22: AddDesc(desc, "PageDown"); break;
		case 0x23: AddDesc(desc, "End"); break;
		case 0x24: AddDesc(desc, "Home"); break;
		case 0x25: AddDesc(desc, "Left"); break;
		case 0x26: AddDesc(desc, "Up"); break;
		case 0x27: AddDesc(desc, "Right"); break;
		case 0x28: AddDesc(desc, "Down"); break;
		case 0x2C: AddDesc(desc, "PrintScreen"); break;
		case 0x2D: AddDesc(desc, "Insert"); break;
		case 0x2E: AddDesc(desc, "Delete"); break;
		case 0x2F: AddDesc(desc, "Help"); break;
		case 0x90: AddDesc(desc, "NumLock"); break;
		case 0x91: AddDesc(desc, "ScrollLock"); break;
		case 0xBA: AddDesc(desc, "SemiColon"); break;
		case 0xBB: AddDesc(desc, "Plus"); break;
		case 0xBC: AddDesc(desc, "Comma"); break;
		case 0xBD: AddDesc(desc, "Minus"); break;
		case 0xBE: AddDesc(desc, "Period"); break;
		case 0xBF: AddDesc(desc, "Slash"); break;
		case 0xC0: AddDesc(desc, "BackQuote"); break;
		case 0xDB: AddDesc(desc, "OpenBracket"); break;
		case 0xDC: AddDesc(desc, "BackSlash"); break;
		case 0xDD: AddDesc(desc, "CloseBracket"); break;
		case 0xDE: AddDesc(desc, "SingleQuote"); break;
		case 0x30: AddDesc(desc, "0"); break;
		case 0x31: AddDesc(desc, "1"); break;
		case 0x32: AddDesc(desc, "2"); break;
		case 0x33: AddDesc(desc, "3"); break;
		case 0x34: AddDesc(desc, "4"); break;
		case 0x35: AddDesc(desc, "5"); break;
		case 0x36: AddDesc(desc, "6"); break;
		case 0x37: AddDesc(desc, "7"); break;
		case 0x38: AddDesc(desc, "8"); break;
		case 0x39: AddDesc(desc, "9"); break;
		case 0x41: AddDesc(desc, "A"); break;
		case 0x42: AddDesc(desc, "B"); break;
		case 0x43: AddDesc(desc, "C"); break;
		case 0x44: AddDesc(desc, "D"); break;
		case 0x45: AddDesc(desc, "E"); break;
		case 0x46: AddDesc(desc, "F"); break;
		case 0x47: AddDesc(desc, "G"); break;
		case 0x48: AddDesc(desc, "H"); break;
		case 0x49: AddDesc(desc, "I"); break;
		case 0x4A: AddDesc(desc, "J"); break;
		case 0x4B: AddDesc(desc, "K"); break;
		case 0x4C: AddDesc(desc, "L"); break;
		case 0x4D: AddDesc(desc, "M"); break;
		case 0x4E: AddDesc(desc, "N"); break;
		case 0x4F: AddDesc(desc, "O"); break;
		case 0x50: AddDesc(desc, "P"); break;
		case 0x51: AddDesc(desc, "Q"); break;
		case 0x52: AddDesc(desc, "R"); break;
		case 0x53: AddDesc(desc, "S"); break;
		case 0x54: AddDesc(desc, "T"); break;
		case 0x55: AddDesc(desc, "U"); break;
		case 0x56: AddDesc(desc, "V"); break;
		case 0x57: AddDesc(desc, "W"); break;
		case 0x58: AddDesc(desc, "X"); break;
		case 0x59: AddDesc(desc, "Y"); break;
		case 0x5A: AddDesc(desc, "Z"); break;
		case 0x70: AddDesc(desc, "F1"); break;
		case 0x71: AddDesc(desc, "F2"); break;
		case 0x72: AddDesc(desc, "F3"); break;
		case 0x73: AddDesc(desc, "F4"); break;
		case 0x74: AddDesc(desc, "F5"); break;
		case 0x75: AddDesc(desc, "F6"); break;
		case 0x76: AddDesc(desc, "F7"); break;
		case 0x77: AddDesc(desc, "F8"); break;
		case 0x78: AddDesc(desc, "F9"); break;
		case 0x79: AddDesc(desc, "F10"); break;
		case 0x7A: AddDesc(desc, "F11"); break;
		case 0x7B: AddDesc(desc, "F12"); break;
		case 0x7C: AddDesc(desc, "F13"); break;
		case 0x7D: AddDesc(desc, "F14"); break;
		case 0x7E: AddDesc(desc, "F15"); break;
		case 0x7F: AddDesc(desc, "F16"); break;
		default: AddDesc(desc, "<Unknown>"); break;
		}
		// End of generated section -- Do not edit!
		key.Description = desc.str();
		ss << "Registered " << desc.str();
	}
	else {
		ss << "Registered '" << key.Name;
	}
	GetKeys().push_back(key);
	LogMessage(ss.str());
}

string _debug_clip = "<clipboard>";
extern "C" char* clip_copy_invoke() {
	if (TestLogEnabled()) {
		TestLog("clip.copy()");
		char* ret = (char* )malloc(_debug_clip.length() + 1);
		strcpy_s(ret, _debug_clip.length() + 1, _debug_clip.c_str());
		return ret;
	}
	LogMessage("clip.copy()");

	char* ret = NULL;
	if (OpenClipboard(GetMainWindow())) {
		HANDLE hData = GetClipboardData(CF_TEXT);
		if (hData) {
			char* clip = (char*)GlobalLock(hData);
			if (clip != NULL) {
				ret = (char*)malloc(strlen(clip) + 2);
				if (ret != NULL) {
					strcpy_s(ret, strlen(clip) + 1, clip);
				}
				GlobalUnlock(clip);
			}
		}
		CloseClipboard();
	}
	return ret;
}

extern "C" void clip_paste_invoke(const char* data) {
	if (TestLogEnabled()) {
		stringstream ss;
		ss << "clip.paste(\"" << data << "\")";
		TestLog(ss.str());
		_debug_clip = string(data);
		return;
	}
	stringstream ss;
	ss << "clip.paste('" << data << "')";
	LogMessage(ss.str());

	if (OpenClipboard(GetMainWindow())) {
		HGLOBAL hMem = GlobalAlloc(GMEM_MOVEABLE, strlen(data) + 2);
		if (hMem != NULL) {
			char* locked = (char*)GlobalLock(hMem);
			if (locked != NULL) {
				strcpy_s(locked, strlen(data) + 2, data);
				GlobalUnlock(hMem);
				EmptyClipboard();
				SetClipboardData(CF_TEXT, hMem);
			}
		}
		CloseClipboard();
	}
}

int _mouse_x = 10;
int _mouse_y = 10;
extern "C" void mouse_position_invoke(int* x, int* y) {
	if (TestLogEnabled()) {
		TestLog("mouse.position()");
		*x = _mouse_x;
		*y = _mouse_y;
		return;
	}
	LogMessage("mouse.position()");
	POINT pt;
	GetCursorPos(&pt);
	*x = pt.x;
	*y = pt.y;
}

extern "C" void mouse_move_invoke(int x, int y, int offset) {
	if (TestLogEnabled()) {
		stringstream ss;
		ss << "mouse.move(" << x << "," << y << "," << offset << ")";
		TestLog(ss.str());
		if (offset) {
			_mouse_x += x;
			_mouse_y += y;
		}
		else {
			_mouse_x = x;
			_mouse_y = y;
		}
		return;
	}
	stringstream ss;
	ss << "mouse.move(" << x << "," << y << "," << offset << ")";
	LogMessage(ss.str());

	if (offset) {
		POINT pt;
		GetCursorPos(&pt);
		x = pt.x + x;
		y = pt.y + y;
	}
	SetCursorPos(x, y);
}

void mouse_helper(DWORD event, int vk, int check) {
	mouse_event(event, 0, 0, 0, NULL);
	for (int bail = 0; bail < 10; bail++) {
		if ((GetKeyState(vk) & 0x8000) == check) {
			break;
		}
		Sleep(50);
	}
}

extern "C" void mouse_click_invoke(int left_down, int left_up, int right_down, int right_up) {
	if (TestLogEnabled()) {
		stringstream ss;
		ss << "mouse.click(" << left_down << "," << left_up << "," << right_down << "," << right_up << ")";
		TestLog(ss.str());
		return;
	}
	stringstream ss;
	ss << "mouse.click(" << left_down << "," << left_up << "," << right_down << "," << right_up << ")";
	LogMessage(ss.str());

	if (left_down) { mouse_helper(MOUSEEVENTF_LEFTDOWN, VK_LBUTTON, 0x8000); }
	if (left_up) { mouse_helper(MOUSEEVENTF_LEFTUP, VK_LBUTTON, 0x0000); }
	if (right_down) { mouse_helper(MOUSEEVENTF_RIGHTDOWN, VK_RBUTTON, 0x8000); }
	if (right_up) { mouse_helper(MOUSEEVENTF_RIGHTUP, VK_RBUTTON, 0x0000); }
}

string GetWindowText(HWND hwnd) {
	int len = GetWindowTextLengthA(hwnd);
	if (len > 0) {
		len++;
		vector<char> buffer(len);
		len = GetWindowTextA(hwnd, buffer.data(), len);
		if (len > 0) {
			return string(buffer.data(), len);
		}
	}
	return "";
}

string GetClassName(HWND hwnd) {
	int len = 250;
	vector<char> buffer((size_t)len + 1);
	len = GetClassNameA(hwnd, buffer.data(), len);
	if (len > 0) {
		return string(buffer.data(), len);
	}
	return "";
}

string HandleToStr(HWND hwnd) {
	stringstream ss;
	ss << hex << (unsigned long long) hwnd;
	return ss.str();
}

HWND StrToHandle(string hwnd) {
	unsigned long long ret;
	stringstream ss;
	ss << hex << hwnd;
	ss >> ret;
	return (HWND)ret;
}

extern "C" void* make_windows_tuple(const char* handle, const char* title, const char* classname);
extern "C" void* windows_get_active_impl() {
	if (TestLogEnabled()) {
		TestLog("get_active()");
		return make_windows_tuple("01", "Win Title", "Win Class");
	}

	LogMessage("get_active()");
	HWND hwnd = GetForegroundWindow();
	string title = GetWindowText(hwnd);
	string classname = GetClassName(hwnd);
	return make_windows_tuple(HandleToStr(hwnd).c_str(), title.c_str(), classname.c_str());
}

vector<void*> _windows;
BOOL CALLBACK EnumWindowsProc(_In_ HWND hwnd, _In_ LPARAM lParam) {
	if (IsWindowVisible(hwnd)) {
		LONG style = GetWindowLong(hwnd, GWL_STYLE);
		if ((style & WS_CHILD) == 0) {
			string title = GetWindowText(hwnd);
			string classname = GetClassName(hwnd);
			_windows.push_back(make_windows_tuple(HandleToStr(hwnd).c_str(), title.c_str(), classname.c_str()));
		}
	}
	return TRUE;
}
extern "C" void windows_list_all_impl(void*** list, int* count) {
	if (TestLogEnabled()) {
		TestLog("list_all()");
		void** temp = (void**)malloc(sizeof(void*) * 2);
		if (temp) {
			temp[0] = make_windows_tuple("01", "Win Title 1", "Win Class 1");
			temp[1] = make_windows_tuple("02", "Win Title 2", "Win Class 2");
		}
		*list = temp;
		*count = 2;
		return;
	}
	LogMessage("list_all()");
	_windows.clear();
	EnumWindows(EnumWindowsProc, NULL);
	void** temp = (void**)malloc(sizeof(void*) * _windows.size());
	if (temp) {
		int i = 0;
		for (auto& cur : _windows) {
			temp[i] = cur;
			i++;
		}
	}
	*list = temp;
	*count = (int)_windows.size();
	return;
}

extern "C" void windows_set_active_impl(const char* handle) {
	if (TestLogEnabled()) {
		stringstream ss;
		ss << "windows.set_active(\"" << handle << "\")";
		TestLog(ss.str());
		return;
	}
	stringstream ss;
	ss << "windows.set_active(\"" << handle << "\")";
	LogMessage(ss.str());

	ShowWindow(StrToHandle(handle), SW_SHOWNORMAL);
	SetForegroundWindow(StrToHandle(handle));
}

extern "C" void windows_get_position_impl(const char* handle, int* x, int* y, int* width, int* height) {
	if (TestLogEnabled()) {
		stringstream ss;
		ss << "windows.get_position(\"" << handle << "\")";
		TestLog(ss.str());
		*x = 0;
		*y = 0;
		*width = 100;
		*height = 100;
		return;
	}

	stringstream ss;
	ss << "windows.get_position(\"" << handle << "\")";
	LogMessage(ss.str());

	WINDOWPLACEMENT wp = { 0 };
	GetWindowPlacement(StrToHandle(handle), &wp);
	*x = wp.rcNormalPosition.left;
	*y = wp.rcNormalPosition.top;
	*width = wp.rcNormalPosition.right - wp.rcNormalPosition.left;
	*height = wp.rcNormalPosition.bottom - wp.rcNormalPosition.top;
}

extern "C" void windows_set_position_impl(const char* handle, int x, int y, int width, int height) {
	if (TestLogEnabled()) {
		stringstream ss;
		ss << "windows.set_position(\"" << handle << "\", " << x << ", " << y << ", " << width << ", " << height << ")";
		TestLog(ss.str());
		return;
	}

	stringstream ss;
	ss << "windows.set_position(\"" << handle << "\", " << x << ", " << y << ", " << width << ", " << height << ")";
	LogMessage(ss.str());
	MoveWindow(StrToHandle(handle), x, y, width, height, TRUE);
}

extern "C" void windows_launch_impl(const char* command_line) {
	if (TestLogEnabled()) {
		stringstream ss;
		ss << "windows.launch(\"" << command_line << "\")";
		TestLog(ss.str());
		return;
	}

	STARTUPINFOA si = { 0 };
	si.cb = sizeof(STARTUPINFOA);
	PROCESS_INFORMATION pi = { 0 };
	char * copy = _strdup(command_line);
	CreateProcessA(NULL, copy, NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS, NULL, NULL, &si, &pi);
	free(copy);
	CloseHandle(pi.hThread);
	CloseHandle(pi.hProcess);
}
